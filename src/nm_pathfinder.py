from math import sqrtfrom heapq import heappush, heappopdef find_path (source_point, destination_point, mesh):    """    Searches for a path from source_point to destination_point through the mesh    Args:        source_point: starting point of the pathfinder        destination_point: the ultimate goal the pathfinder must reach        mesh: pathway constraints the path adheres to    Returns:        A path (list of points) from source_point to destination_point if exists        A list of boxes explored by the algorithm    """    print(f"source: {source_point}, dest: {destination_point}")    detail_points = {}    predecessors = {}    cost = {}    source_box = None    dest_box = None    for box in mesh["boxes"]:        if pos_inside_box(source_point, box):            source_box = box            detail_points[source_box] = source_point        if pos_inside_box(destination_point, box):            dest_box = box            detail_points[dest_box] = destination_point    print(f"source box: {source_box}, dest box: {dest_box}")    if source_box is None or dest_box is None:        print("No path!")        return [], []    if source_box == dest_box:        return [source_point, destination_point], [source_box]    open_boxes = []    heappush(open_boxes, (0, source_box))    predecessors[source_box] = None    cost[source_box] = 0    while open_boxes:        priority, current_box = heappop(open_boxes)        curr_detail_point = detail_points[current_box]        if current_box == dest_box:            path = trace_path(predecessors, detail_points, current_box, destination_point)            return path, detail_points.keys()        curr_cost = cost[current_box]        for neighbor in mesh["adj"][current_box]:            edge_point = clamp_pos_in_box(curr_detail_point, neighbor)            path_cost = curr_cost + dist(curr_detail_point, edge_point)            if neighbor not in cost or path_cost < cost[neighbor]:                cost[neighbor] = path_cost                new_priority = path_cost + heuristic(edge_point, destination_point)                heappush(open_boxes, (new_priority, neighbor))                predecessors[neighbor] = current_box                detail_points[neighbor] = edge_point    print("No path!")    return [], detail_points.keys()def trace_path(predecessors, detail_points, node_box, destination):    path = []    path.append(destination)    while node_box is not None:        path.insert(0, detail_points[node_box])        node_box = predecessors[node_box]    return pathdef pos_inside_box(pos, box):    return box[0] <= pos[0] <= box[1] and box[2] <= pos[1] <= box[3]def clamp(num, min_value, max_value):   return max(min(num, max_value), min_value)def clamp_pos_in_box(pos, box_corners):    xPos = pos[0]    yPos = pos[1]    boxMinX = box_corners[0]    boxMaxX = box_corners[1]    boxMinY = box_corners[2]    boxMaxY = box_corners[3]    return clamp(xPos, boxMinX, boxMaxX), clamp(yPos, boxMinY, boxMaxY)def dist(pos1, pos2):    x1 = pos1[0]    y1 = pos1[1]    x2 = pos2[0]    y2 = pos2[1]    x = x2 - x1    y = y2 - y1    return sqrt(x * x + y * y)def heuristic(pos1, pos2):    return abs(pos2[0] - pos1[0]) + abs(pos2[1] - pos1[1])